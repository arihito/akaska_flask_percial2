# Flask-RESTfulによるREST API構築

## REST APIの基本概念

REST（Representational State Transfer）は、HTTP通信を利用したアーキテクチャスタイルです。リソース指向の設計により、スケーラブルで保守性の高いAPIを構築できます。

## Flask-RESTfulのセットアップ

### インストール
```bash
pip install Flask-RESTful
```

### 基本的な初期化
```python
from flask import Flask
from flask_restful import Resource, Api

app = Flask(__name__)
api = Api(app)

class HelloWorld(Resource):
    def get(self):
        return {'message': 'Hello, World!'}

api.add_resource(HelloWorld, '/')
```

## リソースクラスの実装

### CRUD操作の完全実装

```python
from flask_restful import Resource, reqparse
from models import db, Article

class ArticleListResource(Resource):
    def get(self):
        """記事一覧の取得"""
        articles = Article.query.all()
        return {
            'articles': [
                {
                    'id': a.id,
                    'title': a.title,
                    'content': a.content
                } for a in articles
            ]
        }, 200
    
    def post(self):
        """新規記事の作成"""
        parser = reqparse.RequestParser()
        parser.add_argument('title', required=True, help='タイトルは必須です')
        parser.add_argument('content', required=True)
        args = parser.parse_args()
        
        article = Article(
            title=args['title'],
            content=args['content']
        )
        db.session.add(article)
        db.session.commit()
        
        return {
            'id': article.id,
            'title': article.title
        }, 201

class ArticleResource(Resource):
    def get(self, article_id):
        """特定記事の取得"""
        article = Article.query.get_or_404(article_id)
        return {
            'id': article.id,
            'title': article.title,
            'content': article.content
        }, 200
    
    def put(self, article_id):
        """記事の更新"""
        article = Article.query.get_or_404(article_id)
        
        parser = reqparse.RequestParser()
        parser.add_argument('title')
        parser.add_argument('content')
        args = parser.parse_args()
        
        if args['title']:
            article.title = args['title']
        if args['content']:
            article.content = args['content']
        
        db.session.commit()
        return {'message': '更新しました'}, 200
    
    def delete(self, article_id):
        """記事の削除"""
        article = Article.query.get_or_404(article_id)
        db.session.delete(article)
        db.session.commit()
        return {'message': '削除しました'}, 204

# ルートの登録
api.add_resource(ArticleListResource, '/api/articles')
api.add_resource(ArticleResource, '/api/articles/<int:article_id>')
```

## リクエストパーサーの詳細

### バリデーション付きパーサー
```python
from flask_restful import reqparse

parser = reqparse.RequestParser()

# 必須フィールド
parser.add_argument('username', required=True, help='ユーザー名は必須です')

# 型指定
parser.add_argument('age', type=int, help='年齢は整数で指定してください')

# 選択肢制限
parser.add_argument('status', 
                   choices=['active', 'inactive'],
                   help='statusはactive または inactiveです')

# リスト型
parser.add_argument('tags', action='append')

# 場所の指定（デフォルトはjson）
parser.add_argument('api_key', location='headers')
```

## エラーハンドリング

### カスタムエラーレスポンス
```python
from flask_restful import abort

class ArticleResource(Resource):
    def get(self, article_id):
        article = Article.query.get(article_id)
        if not article:
            abort(404, message=f"記事ID {article_id} は存在しません")
        return {'id': article.id, 'title': article.title}
```

### グローバルエラーハンドラ
```python
@api.representation('application/json')
def output_json(data, code, headers=None):
    """カスタムJSONレスポンス"""
    resp = make_response(json.dumps(data), code)
    resp.headers.extend(headers or {})
    return resp

errors = {
    'UserNotFoundError': {
        'message': "ユーザーが見つかりません",
        'status': 404,
    },
}

api = Api(app, errors=errors)
```

## 認証の実装

### トークンベース認証
```python
from functools import wraps
from flask import request

def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        
        if not token:
            abort(401, message='認証トークンが必要です')
        
        try:
            # トークン検証ロジック
            user = verify_token(token)
        except:
            abort(401, message='無効なトークンです')
        
        return f(*args, **kwargs)
    return decorated

class ProtectedResource(Resource):
    @token_required
    def get(self):
        return {'data': 'protected data'}
```

## ページネーション

```python
from flask import request

class ArticleListResource(Resource):
    def get(self):
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 10, type=int)
        
        pagination = Article.query.paginate(
            page=page,
            per_page=per_page,
            error_out=False
        )
        
        return {
            'articles': [
                {'id': a.id, 'title': a.title}
                for a in pagination.items
            ],
            'total': pagination.total,
            'pages': pagination.pages,
            'current_page': page
        }
```

## レート制限

```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

class ArticleResource(Resource):
    decorators = [limiter.limit("10/minute")]
    
    def get(self, article_id):
        # 1分間に10リクエストまで
        pass
```

## CORS設定

```python
from flask_cors import CORS

# 全エンドポイントでCORS有効化
CORS(app)

# 特定のリソースのみ
api.add_resource(ArticleResource, '/api/articles/<int:id>')
CORS(app, resources={r"/api/*": {"origins": "http://localhost:3000"}})
```

## まとめ

Flask-RESTfulを使うことで、クリーンで保守性の高いREST APIを効率的に構築できます。リソース指向の設計、適切なHTTPステータスコードの使用、エラーハンドリング、認証・認可の実装により、プロダクションレベルのAPIを開発できます。
