# PyJWTによるトークンベース認証の実装

## JWT（JSON Web Token）とは

JWTは、JSON形式の情報を安全に送信するためのトークン規格です。ステートレスな認証方式であり、サーバー側でセッションを保持する必要がないため、スケーラブルなAPI設計に適しています。

## JWTの構造

JWTは3つの部分から構成されます：

```
Header.Payload.Signature
```

### Header（ヘッダー）
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### Payload（ペイロード）
```json
{
  "user_id": 123,
  "username": "john_doe",
  "exp": 1735689600
}
```

### Signature（署名）
ヘッダーとペイロードを秘密鍵で署名したもの。

## PyJWTのセットアップ

### インストール
```bash
pip install PyJWT
```

### 基本的な使い方
```python
import jwt
from datetime import datetime, timedelta

# トークンの生成
def create_token(user_id):
    payload = {
        'user_id': user_id,
        'exp': datetime.utcnow() + timedelta(hours=24)
    }
    token = jwt.encode(payload, 'secret-key', algorithm='HS256')
    return token

# トークンの検証
def verify_token(token):
    try:
        payload = jwt.decode(token, 'secret-key', algorithms=['HS256'])
        return payload
    except jwt.ExpiredSignatureError:
        return None  # トークン期限切れ
    except jwt.InvalidTokenError:
        return None  # 無効なトークン
```

## Flaskでの実装

### ログインエンドポイント
```python
from flask import Flask, request, jsonify
from werkzeug.security import check_password_hash
from models import User
import jwt
from datetime import datetime, timedelta

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'

@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')
    
    user = User.query.filter_by(email=email).first()
    
    if not user or not check_password_hash(user.password, password):
        return jsonify({'message': '認証に失敗しました'}), 401
    
    # トークン生成
    payload = {
        'user_id': user.id,
        'username': user.username,
        'exp': datetime.utcnow() + timedelta(days=1)
    }
    token = jwt.encode(payload, app.config['SECRET_KEY'], algorithm='HS256')
    
    return jsonify({
        'token': token,
        'user': {
            'id': user.id,
            'username': user.username
        }
    }), 200
```

## 認証デコレータの実装

```python
from functools import wraps
from flask import request, jsonify
import jwt

def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = None
        
        # Authorizationヘッダーからトークンを取得
        if 'Authorization' in request.headers:
            auth_header = request.headers['Authorization']
            try:
                token = auth_header.split(" ")[1]  # "Bearer <token>"
            except IndexError:
                return jsonify({'message': 'トークン形式が不正です'}), 401
        
        if not token:
            return jsonify({'message': 'トークンが必要です'}), 401
        
        try:
            # トークンの検証
            payload = jwt.decode(
                token,
                app.config['SECRET_KEY'],
                algorithms=['HS256']
            )
            current_user = User.query.get(payload['user_id'])
            
        except jwt.ExpiredSignatureError:
            return jsonify({'message': 'トークンの有効期限が切れています'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'message': '無効なトークンです'}), 401
        
        # current_userを関数に渡す
        return f(current_user, *args, **kwargs)
    
    return decorated
```

## 保護されたエンドポイントの作成

```python
@app.route('/api/profile', methods=['GET'])
@token_required
def get_profile(current_user):
    return jsonify({
        'id': current_user.id,
        'username': current_user.username,
        'email': current_user.email
    }), 200

@app.route('/api/articles', methods=['POST'])
@token_required
def create_article(current_user):
    data = request.get_json()
    
    article = Article(
        title=data['title'],
        content=data['content'],
        user_id=current_user.id
    )
    db.session.add(article)
    db.session.commit()
    
    return jsonify({'message': '記事を作成しました'}), 201
```

## リフレッシュトークンの実装

アクセストークンとリフレッシュトークンの2種類を発行することで、セキュリティと利便性を両立できます。

```python
def create_tokens(user_id):
    # アクセストークン（短期間有効）
    access_payload = {
        'user_id': user_id,
        'type': 'access',
        'exp': datetime.utcnow() + timedelta(minutes=15)
    }
    access_token = jwt.encode(access_payload, app.config['SECRET_KEY'])
    
    # リフレッシュトークン（長期間有効）
    refresh_payload = {
        'user_id': user_id,
        'type': 'refresh',
        'exp': datetime.utcnow() + timedelta(days=30)
    }
    refresh_token = jwt.encode(refresh_payload, app.config['SECRET_KEY'])
    
    return access_token, refresh_token

@app.route('/api/refresh', methods=['POST'])
def refresh():
    data = request.get_json()
    refresh_token = data.get('refresh_token')
    
    try:
        payload = jwt.decode(refresh_token, app.config['SECRET_KEY'], algorithms=['HS256'])
        
        if payload['type'] != 'refresh':
            return jsonify({'message': '無効なトークンタイプです'}), 401
        
        # 新しいアクセストークンを発行
        new_access_token, _ = create_tokens(payload['user_id'])
        
        return jsonify({'access_token': new_access_token}), 200
        
    except jwt.InvalidTokenError:
        return jsonify({'message': '無効なトークンです'}), 401
```

## クライアント側の実装例（JavaScript）

```javascript
// ログイン
async function login(email, password) {
    const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
    });
    
    const data = await response.json();
    localStorage.setItem('token', data.token);
}

// 認証が必要なリクエスト
async function fetchProfile() {
    const token = localStorage.getItem('token');
    
    const response = await fetch('/api/profile', {
        headers: {
            'Authorization': `Bearer ${token}`
        }
    });
    
    return await response.json();
}
```

## セキュリティのベストプラクティス

1. **SECRET_KEYの管理**: 環境変数で管理し、コードに直接書かない
2. **HTTPS通信**: トークンは必ずHTTPS経由で送信
3. **トークンの有効期限**: 短めに設定（15分〜1時間）
4. **トークンの保存**: localStorage よりも httpOnly Cookie が安全
5. **トークンのブラックリスト**: ログアウト時にトークンを無効化

## まとめ

JWTを使ったトークンベース認証は、RESTful APIにおいて標準的な認証方式です。ステートレスな設計により、スケーラビリティが高く、モバイルアプリやSPAとの連携も容易です。適切なセキュリティ対策を施すことで、安全な認証システムを構築できます。

## トークンのブラックリスト管理

JWTはステートレスであるため、ログアウト時にサーバー側でトークンを失効させる仕組みが必要です。Redisやデータベースを使ったブラックリスト管理が一般的です。

```python
# models.py にブラックリストテーブルを追加
class RevokedToken(db.Model):
    __tablename__ = 'revoked_tokens'
    id = db.Column(db.Integer, primary_key=True)
    jti = db.Column(db.String(120), unique=True, nullable=False)  # JWT ID
    revoked_at = db.Column(db.DateTime, default=datetime.utcnow)

    @classmethod
    def is_revoked(cls, jti):
        return cls.query.filter_by(jti=jti).first() is not None
```

ログアウト時にトークンの JTI（JWT ID）をDBに保存し、以降のリクエストで照合します。

```python
@app.route('/api/logout', methods=['POST'])
@token_required
def logout(current_user):
    token = request.headers['Authorization'].split(' ')[1]
    payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
    jti = payload.get('jti')

    revoked = RevokedToken(jti=jti)
    db.session.add(revoked)
    db.session.commit()

    return jsonify({'message': 'ログアウトしました'}), 200
```

トークン生成時に `jti` フィールド（`str(uuid.uuid4())`）を必ず含めておくことで、個別のトークンを一意に識別できます。

## RS256による非対称鍵署名

HS256（共通鍵）に対し、RS256（RSA非対称鍵）を使うとより安全な署名検証が実現できます。公開鍵を外部サービスに配布でき、秘密鍵を渡さずに署名検証が可能です。

```bash
# 秘密鍵と公開鍵の生成
openssl genrsa -out private.pem 2048
openssl rsa -in private.pem -pubout -out public.pem
```

```python
import jwt

# 秘密鍵でトークンを署名
with open('private.pem', 'r') as f:
    private_key = f.read()

def create_rs256_token(user_id):
    payload = {
        'user_id': user_id,
        'jti': str(uuid.uuid4()),
        'exp': datetime.utcnow() + timedelta(hours=1)
    }
    return jwt.encode(payload, private_key, algorithm='RS256')

# 公開鍵でトークンを検証
with open('public.pem', 'r') as f:
    public_key = f.read()

def verify_rs256_token(token):
    try:
        return jwt.decode(token, public_key, algorithms=['RS256'])
    except jwt.InvalidTokenError:
        return None
```

マイクロサービス構成では、認証サービスが秘密鍵でトークンを発行し、各サービスは公開鍵のみで検証する設計が推奨されます。
